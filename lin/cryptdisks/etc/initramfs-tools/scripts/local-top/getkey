#!/bin/sh

PREREQ="udev"
EXCEPT_DEVLIST=$(/sbin/blkid -o device -t TYPE=crypto_LUKS)

prereqs()
{
    echo "$PREREQ"
}

case $1 in
    # get pre-requisites
    prereqs)
	prereqs
	exit 0
	;;
esac

. /scripts/functions

get_key_from_fs()
{
    mpoint="/flash"
    mkdir -p $mpoint

    wait_for_udev 10
    for dev in $(/sbin/blkid -o device); do
        if [ -z "$(echo -e "$EXCEPT_DEVLIST" | sed -n "\#^$dev\$#p")" ]; then
            EXCEPT_DEVLIST="$EXCEPT_DEVLIST\n$dev"

            FSTYPE=$(/sbin/blkid -o value -s TYPE $dev);
            if mount -o ro -t $FSTYPE $dev $mpoint >/dev/null 2>&1; then
                if [ -s "$mpoint/$MYKEY" ]; then
                    cat "$mpoint/$MYKEY" > "$KEYFILE"
                fi
                umount $dev >/dev/null 2>&1
            fi;
        fi;
        if [ -s "$KEYFILE" ]; then
            return 0
        fi;
    done;
    return 1
}

get_device()
{
    if [ -n "${BOOTIF}" ]; then
            # pxelinux sets BOOTIF to a value based on the mac address of the
            # network card used to PXE boot, so use this value for DEVICE rather
            # than a hard-coded device name from initramfs.conf. this facilitates
            # network booting when machines may have multiple network cards.
            # pxelinux sets BOOTIF to 01-$mac_address
            # strip off the leading "01-", which isn't part of the mac
            # address
            temp_mac=${BOOTIF#*-}
            # convert to typical mac address format by replacing "-" with ":"
            bootif_mac=""
            IFS='-'
            for x in $temp_mac ; do
                    if [ -z "$bootif_mac" ]; then
                            bootif_mac="$x"
                    else
                            bootif_mac="$bootif_mac:$x"
                    fi
            done
            unset IFS
            # look for devices with matching mac address, and set DEVICE to
            # appropriate value if match is found.
            for device in /sys/class/net/* ; do
                    if [ -f "$device/address" ]; then
                            current_mac=$(cat "$device/address")
                            if [ "$bootif_mac" = "$current_mac" ]; then
                                    DEVICE=${device##*/}
                                    break
                            fi
                    fi
            done
    fi
}


update_ip()
{
    temp_ip=""
    i=0
    IFS=':'
    for p in $IP; do
	i=$(($i+1))
	if [ $i -eq 6 -a -z "$p" ]; then
	    get_device
	    p=$DEVICE
	fi
	if [ -z "$temp_ip" ]; then
    	    temp_ip="$p"
    	else
    	    temp_ip="$temp_ip:$p"
    	fi
    done;
    IP=$temp_ip
    unset IFS
}

update_dns()
{
    resolv_conf=/etc/resolv.conf
    rm -f $resolv_conf
    for ns in $DNS $IPV4DNS0 $IPV4DNS1; do
	if [ -n "$ns" -a "$ns" != "0.0.0.0" ]; then
	    echo "nameserver $ns" >> $resolv_conf
	fi
    done;
}

get_key_from_net()
{
    update_ip
    configure_networking
    update_dns
    wait_for_udev 10
    if [ ! -s "$KEYFILE" ]; then
        /sbin/ssh -q -o StrictHostKeyChecking=no -o ConnectTimeout=10 $USERSERV "cat ~/$MYKEY" > "$KEYFILE"
    fi
    if [ -s "$KEYFILE" ]; then
	return 0
    fi;
    return 1;
}

get_key()
{
    get_key_from_fs && return 0
    get_key_from_net && return 0
    return 1
}

main()
{
    while ! get_key; do
	sleep 10;
    done;
}

main


